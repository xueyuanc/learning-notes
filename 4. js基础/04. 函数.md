# 1. 函数基本语法

## 1.1. 函数介绍

函数是一种用于存储代码块的**复杂数据类型**，用于存储特定任务的代码块，解决**代码复用**（一段代码在很多个地方使用）的问题

### 1.1.1. 基础语法

1. 声明函数 : 是一个**存储**过程，此时不会执行函数体代码，类似于变量声明，let->function  变量名->函数名 循环体->函数体

```js
function 函数名(){
              函数体代码： 需要存储的一段代码
          }
```

2. 调用函数 ： 执行函数体代码，调用才会跑代码，一次声明可以多次调用

```js
函数名()
```

### 1.1.2. 函数名命名规范

- 和变量名基本一致
- 尽量使用小驼峰命名（两个单词第一个首字母小写，第二二哥单词首字母大写）
- 第一个单词应该是动词
- 命名建议：常用动词约定

常见的动词约定：

| 单词 | 含义                     |
| ---- | ------------------------ |
| can  | 判断是否可以执行某个动作 |
| has  | 判断是否含有某个值       |
| is   | 判断是否为某个值         |
| get  | 获取某个值               |
| set  | 设置某个值               |
| load | 加载某个值               |

## 1.2. 函数传参

函数参数本质上就是在声明和调用之间传递值。流程就是调用者传递数据给函数，然后执行函数体

- 形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）
- 实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）

```js
		//无形参
        function info() {
            alert('警告！')
        }
        //单形参 
        function bdy(name) {
            console.log(`${name}今天过生日`)
        }
        // 双形参用逗号隔开
        function thing(name, date) {
            console.log(`${name}${date}过生日`)
        }
		//更多的形参之间有逗号隔开
```

> js语法内置的函数：alert('打印')、parseInt('12.2')这种名字后面跟上小括号的本质都是函数的调用

注意点:

1. 函数传参是按照传入顺序一一赋值
2. 函数每一次调用传参过程都是**独立**的，互不影响
3. 函数形参数量和实参数量可以不一致的，没有实参，底层会默认为undefined（变量声明未赋值），开发中尽量保持形参和实参个数一致

> 书写过程：先写声明function sum(){} 再写调用sum() 最后写实参和形参（先写实参），再看怎么处理这个参数，写完函数体，再写返回值

## 1.3. 短路运算（逻辑中断）

js在使用逻辑运算符时，会遇到一种“**短路**”的现场，那一旦能够明确无误地确定整个表达式的值，就不再计算表达式剩余的部分了，称为短路运算/逻辑中断

- && : **一假则假**
- || : **一真则真**
- ! : 取反（没有短路运算，因为只有一个式子）

应用场景：函数默认参数、多条件筛选

介绍一种场景，函数默认参数，我们自己在开发中使用不多。（了解后面很多js框架函数默认参数底层原理）

### 1.3.1. 实现原理

真正的逻辑表达式的值是由两个式子的值来决定的，并不一定是true或false。平时逻辑运算的结果都是布尔型是因为放在if或while或for条件中自动转换成了布尔型 只得到true或false

1. && : 找假。  左边式子值可以（强制Boolean转换）转成false，则无条件返回左边式子的值，右边不执行。 反之无条件返回右边式子的值。

```js
let res = '' && null
console.log(res2) //''
let res1 = 10 && null
console.log(res3) //null
```

2. || : 找真。 左边式子值可以（强制Boolean转换）转成true，则无条件返回左边式子的值，右边不执行。 反之无条件返回右边式子的值。 

```js
let res4 = 10 || null
console.log(res4) //10
```

> 七种布尔转换为false：‘’空字符串、0、-0、NaN、undefined、null、false

### 1.3.2. 代码实现

作用：函数设置默认参数，用的很少，但是也有用。防止用户乱传实参导致函数出现NaN，不够安全，这样写可以保护函数
结果：两个形参只传一个实参，第二个会默认undefined，不加逻辑短路，sum的值为NaN，Number(undefined)=NaN，加了之后不再出现undefined的情况

```js
function getSum(num1, num2) {
      num1 = num1 || 1
      num2 = num2 || 2
      let sum = num1 + num2
      console.log(sum)
    }
    getSum(5)
```

## 1.4. 函数返回值

### 1.4.1. 定义

背景：为什么要有函数返回值？每一个调用者对函数运算结果的处理方式不同。函数本身不处理运算结果，只是返回结果，函数内部不需要输出结果，函数值用来储存或者打印
语法：`function 函数名(){ return 值 }`
使用：`let 变量名 = 函数名() ` 用一个变量存起来或者直接打印

```js
 	function getSum(arr) {
            let sum = 0
            for (let i = 0; i < arr.length; i++) {
                sum += arr[i]
            }
            return sum
        }
        // 调用者A
        let sum = getSum([10, 23, 12, 32])
        document.write(`<button>${sum}</button>`)
        // 调用者B
        let sum1 = getSum([20, 2, 2, 1])
        document.write(`<h1>${sum1}</h1>`)
```

注意点

1. 函数return关键字后面的代码不会执行（只要有return关键字，函数体立即结束执行，但是return语句的代码会执行）类似于循环里面的break，但是return只为函数服务
2. 如果函数没有return语句，则默认返回值是undefined 。只单单只写一个return关键字也返回undefined，但是可以起到结束函数执行的作用
3. return 后面的数据不要换行写，不然默认会结束函数，不执行后面的语句

> - 函数执行的流程：调用者传参数给函数->执行函数体->函数返回函数值给调用者
> - 没有值，控制台或者页面就是undefined，null类似于数字0任何情况不会自动产生，只有手动赋值才会看得到

当函数返回的是一段执行函数，没有值，函数返回值仍然是undefined

```js
function fn(){
            return console.log('111')
        }
    console.log(fn())//undefined
```

### 1.4.2. 函数参数和返回值实例

| 函数类型       | 实例                                                         |
| -------------- | ------------------------------------------------------------ |
| 无参无返回函数 | 京东的首页轮播图每隔3s就滚动，这个函数不需要参数，也没有返回值，就是隔一段时间让代码执行一次，执行函数体 |
| 无参有返回函数 | 有一个函数，返回一个随机颜色，不需要参数，但是有返回值       |
| 有参无返回函数 | 登陆功能，把用户填写的账号密码发送给服务器，只需要传入参数，没有返回值，执行函数体 |
| 有参有返回函数 | 求数组中每一个元素的和，既需要参数，也需要返回值             |

## 1.5. 函数应用示例

### 1.5.1. 求数组最大最小值

需求：求任意数组的最大值或者最小值 ，两个参数 一个数组，一个布尔类型 true为最大值 false为最小值

```js
       function getNum(arr, bool) {
            let num = arr[0]
            for (let i = 1; i < arr.length; i++) {
                if (bool ? num < arr[i] : num > arr[i]) {
                    num = arr[i]
                }
            }
            return num
        }
        console.log(getNum([2, 3, 12, 23], true))
        console.log(getNum([2, 3, 12, 23], false))
```

更简单的方法：if中的语句换成`bool == arr[i] > num1`

### 1.5.2. 判断数组中是否都满足条件

需求：写一个函数：判断数组是不是所有元素都是正数， 是则返回true  否则返回false 

主要有以下三个思路（**思路很重要**）：

1. 用筛选思想，一个newArr，是正数存进去，最后判断newArr数组长度是否等于arr
2. 定义一个count计数变量，有正数就+1，遍历完了看count的值是否等于arr.length，类似于思路一
3. 应用开关思想，定义一个布尔变量初值为真，先遍历，遇到负数直接赋false值，就可以break了

```js
 function getAllPosNum(arr) {
      // 1.声明开关变量
      let bool = true
      // 2.遍历数组，检查是否有满足条件的
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] < 0) {
          bool = false
          // 有就停止遍历
          break
        }
      }
      return bool
    }
    let res = getAllPosNum([34, 212, -23, 2, 4, 53, 0, -34])
    console.log(res)
```

本案例所采用的思想称之为**开关思想**，比如判断数组中是否所有元素满足条件（先开遍历数组，为false时关上停止遍历）开关思想主要分为三个流程：

1. 声明一个开关变量（一般默认为true也可以是别的值，随机应变）
2. 遍历数组，判断每一个元素是否满足条件，遇到不满足修改开关变量为false，直接break，遇到满足的不用修改,因为默认就是true（也可以是别的值）
3. 返回开关变量值

> 重点是弄清楚什么时候关上，停止遍历，即找到for循环中if的条件

应用：
需求：找出数组中有没有元素为10，有的话返回第一个10的下标，没有则返回-1（数组中有没有10）

```js
	function getNum(arr) {
      let bol = -1
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] == 10) {
          bol = i
          break
        }
      }
      return bol
    }
    let num = getNum([2, 2, 3, 10, 23])
    console.log(num)
```

# 2. 作用域与匿名函数

## 2.1. 变量作用域

js变量作用域就是变量可以使用的区域，分为以下三种：

1. **全局作用域**（全局变量）：在函数外面let的变量，可以在页面的任何区域使用和修改
2. **局部作用域**（局部变量）: 在函数里面let的变量，只能在函数内部使用，比如函数的形参和函数里除块级以外的变量
3. **块级作用域**（块级变量）：在分支或循环大括号中let的变量，只能在大括号{}里面使用，也包括小括号()里面的变量比如for循环里面的循环变量i

函数`{}`外面的是一个作用域，因为`()`里面的表示传递参数，由外面传来`fn(this.a)`与`this.a`两个this在一个作用域

```js
        //1.全局变量
        let num = 10
        //函数
        function fn(a, b) {
        //2.局部变量（包括形参）
        // 局部变量只能在函数内部
            let age = 18
            console.log(age)
        }
        console.log(age) //报错
        fn(1, 2)
        // 3.块级变量
        //以for循环为例，包括分支和循环（包括小括号里面的变量）
        for (let i = 1; i <= 6; i++) {
            console.log(i)
        }
        console.log(i) //报错
        // 块级变量只能在大括号内部
        console.log(num) //10
```

变量有一个坑， 特殊情况：如果函数内部或者块级作用域内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐，不符合规范

## 2.2. 作用域链

默认情况下，代码处于全局作用域（0级链）,当声明一个函数之后就会开辟一个局部作用域（1级），而函数里面又可以声明一个函数，又会形成新的作用域（2级），以此类推形成的结构称之为**作用域链**

作用：避免变量污染（变量名相同导致代码冲突）

但是开发中不会出现这样的代码，代码的易读性太差，容易出现歧义，开发中还是会用不同的变量名

```js
    // 最外面的是全局作用域：0级作用域
    let num = 10

    function fn() {
      // 局部：1级作用域
      let num = 20
      console.log(num) //20
      function fn1() {
        // 局部：2级作用域
        let num = 30
        console.log(num) //30
      }
    }
    console.log(num) //10
```

变量访问规则： 就近原则

当你在一个作用域访问变量的之后，首先会看当前作用域有没有声明。如果有则访问。 没有则往上级作用域查找，有没有声明。有则访问，没有则继续往上。直到作用域最顶端0级，如果还没有找到。则程序报错  xxx is not defined

## 2.3. 匿名函数

具名函数：有名字的函数

```js
具名函数：  function 函数名(){}
        function fn1() {
            console.log(1111)
        }
        fn1()
```

匿名函数 : 没有函数名的函数

```js
匿名函数(没有名字的函数无法直接调用) :  
		function (){}
```

匿名函数作用 : 开辟局部作用域，避免全局变量污染，全局变量污染 : 多人开发时，变量名太多了，会增加同名风险

用法：

```js
		//1. let 函数名 = 匿名函数（把代码赋值给变量）
        let fn2 = function () {
            console.log(22222)
        }
        fn2() //调用

        //2. 匿名函数自调用（一声明就调用） ( function(){} )() 后面的小括号相当于调用
        // 注意：自调用语法 前一个语句不能省略分号（理解为编译器不够智能），可以把分号写在自调用函数的开头
        ;
        (function () {
            //局部作用域
            let num = 10
            console.log(num)
        })()
```